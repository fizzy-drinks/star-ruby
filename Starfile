#!/usr/bin/env ruby

require "securerandom"
require "base64"
require "scrypt"
require "./lib/database_adapter/sqlite"

app unhype

db Star::DatabaseAdapter::Sqlite

model(users) {
  id { string { SecureRandom.uuid } }
  username { required string }
  password { required string }
}

model(tokens) {
  value { string { Base64.encode64(SecureRandom.uuid).strip } }
  user_id { required string }
  issued { date { DateTime.now } }
}

model(tasklists) {
  id { string { SecureRandom.uuid } }
  name { required string }
}

model(tasks) {
  id { string { SecureRandom.uuid } }
  title { required string }
  description { string { "" } }
  tasklist_id { required string }
  created_at { date { DateTime.now } }
  modified_at { date { DateTime.now } }
  date_due { date { DateTime.now } }
  closed_at { date }
  deleted_at { date }
}

router {
  before {
    puts "#{request.method} #{request.uri}"

    def now = DateTime.now

    def modified_at = now

    def deleted_at = now

    def authorize!
      use {
        headers {
          authorization { string }
        }
      }

      token = app.models.tokens.find(value: authorization)
      raise Star::Routing::AuthorizationError, "unauthorized" unless token

      @user = app.models.users.find(id: token.user_id)

      raise Star::Routing::AuthorizationError, "unauthorized" unless current_user
    end

    def current_user = @user
  }

  tokens {
    get {
      use {
        headers {
          authorization { required string }
        }
      }

      username, password = authorization.split(":")
      user = app.models.users.find(username:)
      raise Star::Routing::AuthorizationError unless user && SCrypt::Password.new(user.password) == password

      token = app.models.tokens.create(user_id: user.id)
      token.value.to_json
    }
  }

  users {
    post {
      use {
        body {
          username { required string }
          password { required string }
        }
      }

      already_exists = app.models.users.find(username:)
      next {message: "This username is taken!"}.to_json if already_exists

      hashed = SCrypt::Password.create(password)
      app.models.users.create(username:, password: hashed)

      {username:}.to_json(only: %w[username])
    }

    get("me") {
      authorize!
      current_user => {username:, id:}
      {username:, id:}.to_json
    }
  }

  tasklists {
    before {
      authorize!
    }

    get {
      use {
        query {
          name { string }
        }
      }

      app.models.tasklists.where(name:).to_json
    }

    post {
      use {
        body {
          name { required string }
        }
      }

      app.models.tasklists.create(name:).to_json
    }

    scope("{tasklist_id}") {
      before {
        def id = tasklist_id
      }

      get {
        app.models.tasklists.find(id:).to_json
      }

      patch {
        use {
          body {
            name { string }
          }
        }

        app.models.tasklists.update(match: {id:}, update: {name:})
      }

      delete {
        app.models.tasklists.delete(id:)
      }

      tasks {
        get {
          app.models.tasks.where(tasklist_id:).to_json
        }

        post {
          use {
            body {
              title { required string }
              date_due { date { DateTime.now } }
            }
          }

          app.models.tasks.create(tasklist_id:, title:, date_due:).to_json
        }

        scope("{task_id}") {
          before {
            def id = task_id
          }

          get {
            app.models.tasks.find(tasklist_id:, id:).to_json
          }

          patch {
            use {
              body {
                title { string }
                description { string }
                date_due { date }
                closed_at { date }
              }
            }

            update = {title:, date_due:, closed_at:, description:, modified_at:}.filter { |k, v| !v.nil? }.to_h
            app.models.tasks.update(match: {tasklist_id:, id:}, update:).to_json
          }

          delete {
            app.models.tasks.update(match: {tasklist_id:, id:}, update: {deleted_at:}).to_json
          }
        }
      }
    }
  }
}
